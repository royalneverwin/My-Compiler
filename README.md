### 1  编译器概述

#### 1.1  基本功能：

在编译原理实习中，我们需要开发一个将 SysY 语言编译到 RISC-V 汇编的编译器。在编译原理课程的学习中我们知道，编译器结构如下：前端：词法分析、语法分析、语义分析、中间代码生成；后端：优化、目标代码生成。在实习中，我的中间语言设定为Koopa IR，因此我设计的编译器前端为：SysY 语言编译到 Koopa IR；后端为：Koopa IR 生成到 RISC-V 汇编。

我的编译器可以实现对所有SysY语言的正确编译，并且具有基本的语义分析功能，可以排查出用户的代码错误并返回错误原因。



#### 1.2  主要特点：

针对Koopa IR和riscv的输出，我使用的是On-the-fly方法，边扫描边生成，可以逐步生成代码的各个部分，并增量式添加到最终的代码中，这样避免了属性传递时代码过长造成的性能降低。





### 2  编译器设计

#### 2.1  主要模块组成

基本思想：把文本形式的源代码转换为内存中的一种树形的数据结构AST，再对树形结构进行分析生成Koopa IR，最后将Koopa IR转换成riscv。

##### 2.1.1  词法分析

把文本形式的源代码转换为数据结构形式的AST方法第一部分：词法分析。词法分析（lexer）把字节流转换为单词流，在sysy.l中实现。

##### 2.1.2  语法分析

把文本形式的源代码转换为数据结构形式的AST方法第二部分：语法分析。语法分析（parser）把token流转变成AST，在sysy.y中实现。

其中AST的数据结构在AST.h中实现：创建BaseAST基类，其他所有非终结符号创建为BaseAST的派生类，彼此之间用指针连接。

对于一些特殊的EBNF符号，创建特殊的临时AST进行处理。

##### 2.1.3  语义分析

语法分析结束后还可以适当性的对结果进行语义分析，对不符合语义分析的程序我们终止编译过程，并输出错误原因。在AST.h中实现。

e.g. 

* ConstExp使用的IDENT一定要是常量
* 不允许同一个block内声明重名的变量或常量
* 有返回值的函数一定要有返回语句，没有返回值的函数一定不能有return 0类似的语句
* 变量或常量类型不能是void，函数类型只有int 和 void
* 除数不能为0，不能mod 0
* 调用函数时函数参数的使用是否正确
* 不会出现连续的ret语句
* 数组初始化的格式是否正确

##### 2.1.4  AST转Koopa IR

使用AST中的Dump函数On-the-fly式的生成Koopa IR。生成Koopa IR时使用的所有成员函数都通过虚函数的形式实现。在AST.h中实现。

##### 2.1.5  Koopa IR转riscv

遍历Koopa IR的同时On-the-fly式的生成riscv指令。在main.cpp中实现。



#### 2.2  主要数据结构

`class BaseAST `：所有非终结符的基类。

`typedef struct {...}  IdentInfo`：存储IDENT对应的信息：name、type、val等。

`typedef struct tables {xxx} IdentTables`：符号表，里面存储了所有IDENT的信息、符号表的名字、和指向上一层和下一层符号表的指针。

`typedef struct {...} instInfo`：存储指令对应的信息：返回值

`unordered_map<koopa_raw_value_t , instInfo> instTable`：指令表，存储所有访问过的指令对应的信息

还有其他小的数据类型如symbol、ifLast、curEnd、whileEntry、whileEnd、curStatus、curBlockIndex、curFunc、ifGlobal、SPoffset等就不一一说明，都是为了生成Koopa IR和riscv指令时的辅助类型。



#### 2.3  主要算法设计考虑

用DFS遍历AST树得到Koopa IR，这部分在AST.h中实现。

同样也是DFS遍历raw program，得到riscv，这部分在main.cpp中实现。



### 3  编译器实现

#### 3.1  对所涉工具软件的介绍

##### 3.1.1  Docker

Docker 是容器技术的一种实现, 而容器技术又是一种轻量级的虚拟化技术. 你可以简单地把容器理解成虚拟机: 容器中可以运行另一个操作系统, 它和你的宿主系统是隔离的。

当然, 容器和虚拟机实际上并不相同, 你若感兴趣可自行 STFW, 此处不做过多介绍。

基于 Docker, 我们可以很方便地完成各类 “配环境” 的操作:

- 负责配置环境的人只需要写好 `Dockerfile`, 然后使用 Docker 构建镜像即可. 和环境相关的所有内容, 包括系统里的某些配置, 或者安装的工具链, 都被封装在了镜像里。
- 需要使用环境的人只要拿到镜像, 就可以基于此创建一个容器, 然后在里面完成自己的工作. 开箱即用, 不需要任何多余的操作, 十分省时省力。
- 如果某天不再需要环境, 直接把容器和镜像删除就完事了, 没残留也不拖泥带水, 干净又卫生。

##### 3.1.2  Koopa IR

Koopa IR 是一种专为北京大学编译原理课程实践设计的教学用的中间表示 (IR), 它在设计上类似 LLVM IR, 但简化了很多内容, 方便大家上手和理解。

Koopa IR 是一种强类型的 IR, IR 中的所有值 (`Value`) 和函数 (`Function`) 都具备类型 (`Type`). 这种设计避免了一些 IR 定义上的模糊之处, 例如之前的教学用 IR 完全不区分整数变量和数组变量, 很容易出现混淆; 同时可以在生成 IR 之前就确定 IR 中存在的部分问题, 例如将任意整数作为内存地址并向其中存储数据。

Koopa IR 中, 基本块 (basic block) 必须是显式定义的. 即, 在描述函数内的指令时, 你必须把指令按照基本块分组, 每个基本块结尾的指令只能是分支/跳转/函数返回指令之一. 在 IR 的数据结构表示上, 指令也会被按照基本块分类. 这很大程度上方便了 IR 的优化, 因为许多优化算法都是在基本块的基础上对程序进行分析/变换的。

Koopa IR 还是一种 SSA 形式的 IR。

##### 3.1.3  RISCV

RISC-V, 读作 “risk-five”, 是由加州大学伯克利分校设计并推广的第五代 RISC 指令系统体系结构 (ISA). RISC-V 没有任何历史包袱, 设计简洁, 高效低能耗, 且高度模块化——最主要的, 它还是一款完全开源的 ISA.

RISC-V 的指令系统由基础指令系统 (base instruction set) 和指令系统扩展 (extension) 构成. 每个 RISC-V 处理器必须实现基础指令系统, 同时可以支持若干扩展. 常用的基础指令系统有两种:

- `RV32I`: 32 位整数指令系统。
- `RV64I`: 64 位整数指令系统. 兼容 `RV32I`。

在课程中，我们的目标是将代码编译为RV32IM范围内的汇编指令。

##### 3.1.4  Make

**Make**是一个规则解释语言，也是一种宏语言。 一个规则包括target，及其构建的依赖项（dependencies）；comands前面必须是'\t'（Tab键），给出由依赖项构建target需要调用的shell脚本命令。 在**make**调用时可以指定特定的target， 规则通常分为具体规则、模式规则、隐含规则等。

通俗来说，*GNU Make* 就是用来控制生成可执行文件的这么一个工具，它的目的就是把一个已经写好的源文件生成为可执行的程序。想要完成这个任务，*Make*需要一个*makefile*的文件来记录如何生成我们想要的程序，这里面包含了目标对象，已经生成这个目标对象所需要依赖的其他文件。如果，你已经写好了一个程序，你需要为其写一个 *makefile*，然后使用*Make*去编译和安装。

##### 3.1.5  Bison

Bison是一种通用解析器生成器，它将带注释的上下文无关文法转换为使用LALR（1）解析器表的确定性LR或广义LR（GLR）解析器 。作为一项实验性功能，Bison还可以生成IELR（1）或规范的LR（1）解析器表。一旦您精通Bison，就可以使用它来开发各种语言解析器，从用于简单台式计算器的语言解析器到复杂的编程语言。 Bison与Yacc向上兼容：所有正确编写的Yacc语法都应与Bison一起使用，而无需进行任何更改。

##### 3.1.6  Yacc

yacc(Yet Another Compiler Compiler)，是Unix/Linux上一个用来生成编译器的编译器（编译器代码生成器）.

使用巴克斯范式(BNF)定义语法，能处理上下文无关文法(context-free)。出现在每个产生式左边(left-hand side：lhs)的符号是非终端符号，出现在产生式右边(right-hand side：rhs)的符号有非终端符号和终端符号，但终端符号只出现在右端。

yacc是开发编译器的一个有用的工具,采用LR（1）（实际上是LALR(1)）语法分析方法。

##### 3.1.7  Git

Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。

Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。我使用Git和Gitlab对编译器程序进行项目版本管理。



#### 3.2  各个阶段的编码细节

#### 3.2.1  Lv0

没什么好讲的 按照教程配置环境就可以

#### 3.2.2  Lv1

1. 教程中给了形如“//xxx”的行注释，自行处理形如“/\*xxxxx\*/”的块注释，在sysy.l中定义 " BlockComment =  \/\\\*((\[\^\\\"\\\*\]\*\) \| \(\\\*\*\\\"\[\^\\\"\]\*\\\"\) \| \(\\\*\+\[\^\\\"\\\/\\\*\]\)\)\*\\\*\*\\\*\\\/ "进行处理

2. 关于%code requires：**%code [qualifier] { code_seg }**这个选项就是用来指定代码段`code_seg`放在什么位置。其中`qualifier`可以为空、`requires`、`provides`、`top`或者`imports`。

   所以对于**%code requires { code_seg }**，qualifier为requires。此时代码段code_seg只能是C/C++，将被放在声明文件（也就是--defines生成的文件）和实现文件（也就是--output生成的文件）中定义YYSTYPE、YYLTYPE之前。可以将包含的头文件放在这里。否则--defines生成头文件时可能没有。

   由于我们自己写了个头文件AST.h，所以可以在%code requires中`#include "AST.h"`

3. 生成Koopa IR的方式：遍历AST，输出文本形式的IR。这里的遍历我们选择DFS（深度优先遍历）。

4. 用strcmp判断命令是-koopa还是-riscv。

5. 用freopen函数重定向stdout到输出文件中，这样在AST的Dump中就可以直接用cout输出Koopa IR了，使用的是边遍历边生成的方式。（最好在生成Koopa IR后再用freopen把stdout改回去）。

#### 3.2.3  Lv2

1. 我们用DFS的思想访问raw program，定义一系列的访问函数

#### 3.2.4  Lv3

1. c++标准决定，c++联合体中不允许定义有自定义构造函数的类，同理，不允许定义自定义了拷贝构造函数、析构函数的类。因此union中只能存BaseAST \*，不能村unique_ptr\<BaseAST *\>。所以对于EBNF中的`|`规则，我没有考虑用union表示不同翻译方案，而是将所有翻译方案需要包含的对象全部在AST中声明，并用kind表示该非终结符使用哪一种翻译方案。
2. 对于临时符号“%i”的生成，我们定义全局变量cnt，保证每次生成的临时符号数字不同
3. 根据生成Koopa IR是进行DFS遍历的特性，我们定义`stack<int> symbol`用来存放每个Dump的结果，对于一个父AST，我们调用其全部子AST的Dump后，将Dump的结果全部push到symbol中，父AST在需要使用子AST的结果时，从symbol中pop即可得到子AST Dump的结果（例如临时符号、变量等）。
4. 在生成riscv时。我们定义寄存器表regList存放空闲的寄存器，所有临时符号暂时都用寄存器存，在binary指令每次结束后，我们都将不需要的寄存器再次放回寄存器表中，避免寄存器用光
5. 在生成riscv时，我们不再使用栈存放每个binary指令的结果（其实这里也可以用栈，但是到后面if else开始就不行了唉），而是定义一个指令表`unordered_map<koopa_raw_value_t , instInfo> instTable`，存放每个指令对应的返回值，这样访问已经访问过的指令可以直接返回返回值而不是再访问一遍
6. 由于基本上所有指令都需要寄存器操作，所以我们在读取到立即数的时候，不是直接返回立即数，而是先将立即数存到寄存器中再返回寄存器。这也方便了后面判断指令返回值是寄存器还是栈指针（看第一个字符是不是数字就行）。
7. 在4中我们每次binary操作完就还回不再使用的寄存器，以及在随后有局部和全局变量后对变量的加减乘除都需要先存到寄存器，如果存在连续binary计算，应该每次取两个，计算出一个结果后再取第三个，否则如果先把所有的计算所需变量都存到寄存器中，寄存器不够用的。为了实现这一点，在二元运算的AST中，我们应该规定好每个子AST的Dump的调用顺序。比如对于LAndExpAST，我们先调用子AST land_exp->Dump()，再调用子AST eq_exp->Dump()。
8. 注意函数返回值永远存在a0中。
9. Koopa IR只支持按位与或，不支持逻辑与或，我们可以通过别的语句拼凑出来（但这也不重要，反正后面要改成短路运算）。

#### 3.2.5  Lv4

1. 对于定义的变量和常量，我们定义数据结构identInfo和符号表IdentTables，每次新的block就会创建新的IdentTables，且IdentTables用指针互相连接，可以实现向上查询ident。
2. 从Lv4开始，所有的临时变量和变量，都存到栈上，只有在需要用到寄存器操作的时候再转存到寄存器上。
3. 每次指令返回值存放的栈偏移量用一个stack存储。每次读取top然后把+4的值在存回去。（在有了数组后就是+数组的size）
4. 对于常量，我们在声明的时候就计算出它的常量值，使用GetConstVal( )虚函数返回AST计算出的value值。
5. 对于LVal，只有一个ident成员变量表示变量名，Dump中没有任何其他操作，但在PrimaryAST中对LVal有一些操作，所以使用GetIdent( )虚函数返回AST对应的ident值用于父AST操作。
6. 对于EBNF中的{...}表示，我们用std::vector存放0个或多个该AST，同时定义临时AST用于语法分析。临时AST有两个指针，分别指向个体AST和该个体后的所有AST。使用GetItem( )和GetConstItem( )虚函数获得这两个指针。

#### 3.2.6  Lv5

1. 对于EBNF中的[...]表示，我们用空指针表示该项出现0次。

#### 3.2.7  Lv6

1. 对 if_else基本块的处理，我们使用ifCnt给新的基本块命名。

2. if_else 和 while 最复杂的地方在于跳转的部分（br和jump）。这里简单列举几种情况：

   * 如果这个if_else 或 while 是最后一条stmt，且没有父的if_else 或 while 包着它，则一定需要一个end，不然没地方跳，新增end。

   * 如果这个if_else 或 while 是最后一条stmt，且有父的if_else 或 while 包着它，则分况讨论应该怎么跳。

   * 如果这个if_else 或 while 不是最后一条stmt，则要有end，确保跳转到它的下一条stmt。

   * ...

     在这里我定义了`stack<int> ifLast`、`stack<string> curEnd`、`whileCnt`、`stack<string> whileEntry`、`stack<string> whileEnd`、`stack<bool> curStatus`、`stack<int> curBlockIndex`等多个全局变量只为了正确判断跳转...

3. 为了避免在if_else的子stmt里出现了br，jump或ret的基本块结尾语句，我们定义变量ifBlockEnd记录这个基本块是否到了结尾（出现以上的语句就说明到结尾了），如果没到结尾，则在父的if_else中正常进行jump或ret，若到结尾则跳过父的if_else中jump或ret语句。同理，如果到了基本块的结尾，我们也会忽略没有Dump的stmt，直接结束这个block的Dump。（这样也确保了只有一个ret）

4. 短路运算就是自己写一个if else，没什么好说的。

5. 避免if_else 二义性的方法：根据下面的EBNF自行修改自己的EBNF

   Stmt -> MatchedStmt | OpenStmt

   MatchedStmt -> if (Exp) MatchedStmt else MatchedStmt | OtherStmt

   OpenStmt -> if (Exp) Stmt | if (Exp) MatchedStmt else OpenStmt

#### 3.2.8  Lv7

基本上和if_else一样，难点也一样。

#### 3.2.9  Lv8

1. 注意函数参数如果超过8个要放到栈上。
2. 在引入全局变量后，会产生规约-规约冲突，为了消除规约-规约冲突，修改AST，将var_decl和funcDef的type提出来，并将var_decl和funcDef合并成一个新的ast，而const_decl特殊处理。（因为它开头有个const，不会出问题）
3. 我们定义一个全局符号表，存放函数、变量等

#### 3.2.10  Lv9

1. 我用递归的方法，实现数组的Koopa IR的类型声明。

2. 对于多维数组，用AllocInitVal和AllocValForGlobal实现Koopa IR的初始化。

3. 对于多维数组，用GetConstVals虚函数得到多维数组的初始值（就是在这里进行伟大的多维数组初始化的矫正）。

   （参考原理：记录待处理的 nn 维数组各维度的总长 $len_1, len_2, \cdots, len_n$. 比如 `int[2][3][4]` 各维度的长度分别为 2, 3 和 4；依次处理初始化列表内的元素, 元素的形式无非就两种可能: 整数, 或者另一个初始化列表；遇到整数时, 从当前待处理的维度中的最后一维 (第 n 维) 开始填充数据；遇到初始化列表时:

   - 当前已经填充完毕的元素的个数必须是 $len_n$ 的整数倍, 否则这个初始化列表没有对齐数组维度的边界, 你可以认为这种情况属于语义错误.
   - 检查当前对齐到了哪一个边界, 然后将当前初始化列表视作这个边界所对应的最长维度的数组的初始化列表, 并递归处理. 比如:
     - 对于 `int[2][3][4]` 和初始化列表 `{1, 2, 3, 4, {5}}`, 内层的初始化列表 `{5}` 对应的数组是 `int[4]`.
     - 对于 `int[2][3][4]` 和初始化列表 `{1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, {5}}`, 内层的初始化列表 `{5}` 对应的数组是 `int[3][4]`.
     - 对于 `int[2][3][4]` 和初始化列表 `{{5}}`, 内层的初始化列表 `{5}` 之前没出现任何整数元素, 这种情况其对应的数组是 `int[3][4]` )

4. 在数组参数或使用数组元素时，用GetVals虚函数得到LVal中多维数组的下标。

5. 指针的东西太多了！！！这里有一点明确一下，alloc的结果都是指针，但需要明确的是：我的alloc指令返回的结果就是一个值，比如0(sp)，我的全局alloc返回的结果也是一个值，比如0(t1)，但我的getelemptr和getptr返回的结果虽然是一个类0(sp)的结果，但上面存的依然是个指针，所以要多load一遍。（也就是说，不能根据返回值类型判断是否是指针，而是要根据指令类型判断！我也不知道为什么我同一个返回值类型会返回不同类型的值....）





### 4 自测情况说明

#### 4.1  Case 1

针对if else语句，我们构造测试用例如下：

```c++
int main() {
  int a = 0;
  int b = 1;
  int c = 2;
  if(a == 0) {
    {
      if(b == 1) {
				c = 2;
      }
    }
    c = 3;
  }
  return c;
}
```

用一个新的block块包住if里面嵌套的if，由于是一个新的block，所以这里的第二个if无法探测到这个block之后的语句c = 3，所以if结束后会跳转到return c，我的编译器结果是2。

于是我记录下if外面的所有block，当且仅当每个block都是所在block的最后一个stmt的时候，才说明if后面没有语句，才会跳转到其外围的if的end。这样就可以探测到c = 3语句了。



#### 4.2  Case 2

对于在线测评中的测试样例Long_Function，我的编译器可以正常生成Koopa IR指令，但生成riscv指令时会报错。经过与助教的讨论可知，br指令不能跳转到超过2048字节的地址，因此出错。由于我不知道应该使用什么指令去代替br，因此这道题我即使在线测评Fail，也知道问题出在哪，但也无法修改，很是遗憾。





### 5  实习总结

#### 5.1  收获与体会

##### 5.1.1  主要的收获

* 可以更熟悉的使用docker、git、make等工具。
* 对编译器的结构和编译过程有了十分深刻的认识。
* 极大的加强了我大型代码的编写水平。
* 极大的加强了我的Debug水平。

##### 5.1.2  学习过程中的难点

* 代码量大，编写的代码容易出错。
* 代码量大，出现Bug不好调试。
* 随着Lv的逐渐深入，前面实现某种功能所使用的数据结构或者方法已经不再适用，需要根据后面的要求重新编写，出现进度倒退的现象。
* 部分在线测评样例无法看到，只能手动编写测试样例猜测问题所在进行Debug。



